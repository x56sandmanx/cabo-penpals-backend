import { ServiceError } from '@grpc/grpc-js';
import { ClientRequest } from '../../../proto/ai/inworld/engine/world-engine_pb';
import { InworldPacket as ProtoPacket } from '../../../proto/ai/inworld/packets/packets_pb';
import { ApiKey, Awaitable, Extension, GenerateSessionTokenFn, GetterSetter, InternalClientConfiguration, User } from '../common/data_structures';
import { SessionContinuation } from '../entities/continuation/session_continuation.entity';
import { InworldPacket } from '../entities/inworld_packet.entity';
import { Session } from '../entities/session.entity';
import { SessionToken } from '../entities/session_token.entity';
import { EventFactory } from '../factories/event';
interface ConnectionProps<InworldPacketT> {
    apiKey: ApiKey;
    name?: string;
    user?: User;
    client?: ClientRequest;
    config?: InternalClientConfiguration;
    sessionGetterSetter?: GetterSetter<Session>;
    sessionContinuation?: SessionContinuation;
    onDisconnect?: () => Awaitable<void>;
    onError: (err: ServiceError) => Awaitable<void>;
    onMessage?: (message: InworldPacketT) => Awaitable<void>;
    generateSessionToken?: GenerateSessionTokenFn;
    extension?: Extension<InworldPacketT>;
}
export declare class ConnectionService<InworldPacketT extends InworldPacket = InworldPacket> {
    private state;
    private scene;
    private sessionToken;
    private stream;
    private connectionProps;
    private disconnectTimeoutId;
    private eventFactory;
    private intervals;
    private packetQueue;
    private engineService;
    private stateService;
    private onDisconnect;
    private onError;
    private onMessage;
    private logger;
    constructor(props: ConnectionProps<InworldPacketT>);
    isActive(): boolean;
    isAutoReconnected(): boolean;
    generateSessionToken(): Promise<SessionToken>;
    getSessionState(): Promise<import("./gprc/state_serialization_client_grpc.service").SessionState>;
    openManually(): Promise<void>;
    close(): void;
    getEventFactory(): EventFactory;
    getCharactersList(): Promise<import("..").Character[]>;
    open(): Promise<void>;
    send(getPacket: () => ProtoPacket): Promise<InworldPacketT>;
    private write;
    private writeToStream;
    private loadScene;
    ensureSessionToken(props?: {
        beforeLoading: () => void;
        sessionToken?: SessionToken;
    }): Promise<SessionToken>;
    private getOrLoadScene;
    private scheduleDisconnect;
    private cancelScheduler;
    private releaseQueue;
    private clearQueue;
    private convertPacketFromProto;
}
export {};
