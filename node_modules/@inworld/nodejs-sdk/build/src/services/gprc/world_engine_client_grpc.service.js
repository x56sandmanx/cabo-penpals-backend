"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorldEngineClientGrpcService = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const world_engine_grpc_pb_1 = require("../../../../proto/ai/inworld/engine/world-engine_grpc_pb");
const world_engine_pb_1 = require("../../../../proto/ai/inworld/engine/world-engine_pb");
const util_1 = require("util");
const os = require("os");
const key_signature_1 = require("../../auth/key_signature");
const config_1 = require("../../common/config");
const constants_1 = require("../../common/constants");
const helpers_1 = require("../../common/helpers");
const logger_1 = require("../../common/logger");
const { version } = require('../../../../package.json');
class WorldEngineClientGrpcService {
    constructor() {
        this.config = config_1.Config.getInstance();
        this.address = this.config.getHost();
        this.ssl = this.config.getSSL();
        this.grpcOptions = Object.assign({}, helpers_1.grpcOptions);
        this.client = new world_engine_grpc_pb_1.WorldEngineClient(this.config.getHost(), this.ssl ? grpc_js_1.credentials.createSsl() : grpc_js_1.credentials.createInsecure(), Object.assign({}, helpers_1.grpcOptions));
        this.logger = logger_1.Logger.getInstance();
    }
    generateSessionToken(apiKey, scene) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = new grpc_js_1.Metadata();
            const request = new world_engine_pb_1.GenerateTokenRequest();
            const resource = `workspaces/${constants_1.SCENE_PATTERN.exec(scene)[1]}`;
            request.setKey(apiKey.key);
            request.setResourcesList([resource]);
            metadata.add('authorization', key_signature_1.KeySignature.getAuthorization({
                apiKey,
                host: this.config.getHost(),
            }));
            const response = yield (0, util_1.promisify)(this.client.generateToken.bind(this.client))(request, metadata);
            this.logger.debug({
                action: 'Generate token',
                data: {
                    address: this.address,
                    ssl: this.ssl,
                    metadata: metadata.toJSON(),
                    request: request.toObject(),
                    response: response.toObject(),
                },
            });
            return response;
        });
    }
    loadScene(props) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const { capabilities, name, sessionContinuation, sessionToken, user } = props;
            const request = new world_engine_pb_1.LoadSceneRequest()
                .setName(name)
                .setCapabilities(capabilities)
                .setClient(this.getClient(props))
                .setUserSettings(this.getUserSettings(props));
            if (user === null || user === void 0 ? void 0 : user.fullName) {
                request.setUser(new world_engine_pb_1.UserRequest().setName(user.fullName));
            }
            if ((sessionContinuation === null || sessionContinuation === void 0 ? void 0 : sessionContinuation.previousDialog) ||
                (sessionContinuation === null || sessionContinuation === void 0 ? void 0 : sessionContinuation.previousState)) {
                const continuation = new world_engine_pb_1.SessionContinuation();
                if (sessionContinuation.previousState) {
                    continuation.setPreviousState(sessionContinuation.previousState);
                }
                if (sessionContinuation.previousDialog) {
                    continuation.setPreviousDialog(sessionContinuation.previousDialog.toProto());
                }
                request.setSessionContinuation(continuation);
            }
            const metadata = this.getMetadata(sessionToken);
            const finalRequest = ((_b = (_a = props.extension) === null || _a === void 0 ? void 0 : _a.beforeLoadScene) === null || _b === void 0 ? void 0 : _b.call(_a, request)) || request;
            const response = yield (0, util_1.promisify)(this.client.loadScene.bind(this.client))(finalRequest, metadata);
            this.logger.debug({
                action: 'Load scene',
                data: {
                    address: this.address,
                    ssl: this.ssl,
                    grpcOptions: this.grpcOptions,
                    metadata: metadata.toJSON(),
                    request: request.toObject(),
                    response: response.toObject(),
                },
                sessionId: sessionToken.sessionId,
            });
            (_d = (_c = props.extension) === null || _c === void 0 ? void 0 : _c.afterLoadScene) === null || _d === void 0 ? void 0 : _d.call(_c, response);
            return response;
        });
    }
    session(props) {
        const { sessionToken, onDisconnect, onError, onMessage } = props;
        const metadata = this.getMetadata(sessionToken);
        const connection = this.client.session(metadata);
        this.logger.debug({
            action: 'Open session',
            data: {
                address: this.address,
                ssl: this.ssl,
                grpcOptions: this.grpcOptions,
                metadata: metadata.toJSON(),
            },
            sessionId: sessionToken.sessionId,
        });
        if (onMessage) {
            connection.on('data', onMessage);
        }
        if (onDisconnect) {
            connection.on('close', onDisconnect);
        }
        if (onError) {
            connection.on('error', (err) => {
                onError(err);
                connection.end();
            });
        }
        return connection;
    }
    getMetadata(sessionToken) {
        const metadata = new grpc_js_1.Metadata();
        metadata.add('session-id', sessionToken.sessionId);
        metadata.add('authorization', `${sessionToken.type} ${sessionToken.token}`);
        return metadata;
    }
    getClient(props) {
        var _a;
        const containerInfo = `${os.type()} ${os.release()} (Node.js ${process.version})`;
        const description = [constants_1.CLIENT_ID, version, containerInfo];
        if ((_a = props.client) === null || _a === void 0 ? void 0 : _a.getId()) {
            description.push(props.client.getId());
        }
        return new world_engine_pb_1.ClientRequest()
            .setId(constants_1.CLIENT_ID)
            .setVersion(version)
            .setDescription(description.join('; '));
    }
    getUserSettings(props) {
        var _a, _b;
        const { user } = props;
        if ((_b = (_a = user === null || user === void 0 ? void 0 : user.profile) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.length) {
            return new world_engine_pb_1.UserSettings().setPlayerProfile(new world_engine_pb_1.UserSettings.PlayerProfile().setFieldsList(user.profile.fields.map(({ id, value }) => new world_engine_pb_1.UserSettings.PlayerProfile.PlayerField()
                .setFieldId(id)
                .setFieldValue(value))));
        }
    }
}
exports.WorldEngineClientGrpcService = WorldEngineClientGrpcService;
