"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionService = void 0;
const data_structures_1 = require("../common/data_structures");
const logger_1 = require("../common/logger");
const inworld_packet_entity_1 = require("../entities/inworld_packet.entity");
const scene_entity_1 = require("../entities/scene.entity");
const session_token_entity_1 = require("../entities/session_token.entity");
const event_1 = require("../factories/event");
const state_serialization_client_grpc_service_1 = require("./gprc/state_serialization_client_grpc.service");
const world_engine_client_grpc_service_1 = require("./gprc/world_engine_client_grpc.service");
class ConnectionService {
    constructor(props) {
        this.state = data_structures_1.ConnectionState.INACTIVE;
        this.eventFactory = new event_1.EventFactory();
        this.intervals = [];
        this.packetQueue = [];
        this.engineService = new world_engine_client_grpc_service_1.WorldEngineClientGrpcService();
        this.stateService = new state_serialization_client_grpc_service_1.StateSerializationClientGrpcService();
        this.logger = logger_1.Logger.getInstance();
        this.connectionProps = props;
        this.onDisconnect = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            this.state = data_structures_1.ConnectionState.INACTIVE;
            yield ((_b = (_a = this.connectionProps).onDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a));
        });
        this.onError = this.connectionProps.onError;
        this.onMessage = (packet) => __awaiter(this, void 0, void 0, function* () {
            var _c, _d, _e;
            (_d = (_c = this.connectionProps).onMessage) === null || _d === void 0 ? void 0 : _d.call(_c, this.convertPacketFromProto(packet));
            this.logger.debug({
                action: 'Receive packet',
                data: {
                    packet: packet.toObject(),
                },
                sessionId: (_e = this.sessionToken) === null || _e === void 0 ? void 0 : _e.sessionId,
            });
        });
    }
    isActive() {
        return this.state === data_structures_1.ConnectionState.ACTIVE;
    }
    isAutoReconnected() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.connectionProps.config) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.autoReconnect) !== null && _c !== void 0 ? _c : true;
    }
    generateSessionToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const proto = yield this.engineService.generateSessionToken(this.connectionProps.apiKey, this.connectionProps.name);
            return session_token_entity_1.SessionToken.fromProto(proto);
        });
    }
    getSessionState() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const token = yield this.ensureSessionToken();
                return this.stateService.getSessionState({
                    sessionToken: token,
                    scene: this.connectionProps.name,
                });
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    openManually() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.isAutoReconnected()) {
                    throw Error('Impossible to open connection manually with `autoReconnect` enabled');
                }
                if (this.isActive()) {
                    throw Error('Connection is already open');
                }
                return this.open();
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    close() {
        var _a, _b, _c;
        this.cancelScheduler();
        this.state = data_structures_1.ConnectionState.INACTIVE;
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeListener('data', this.onMessage);
        (_b = this.stream) === null || _b === void 0 ? void 0 : _b.cancel();
        this.clearQueue();
        if (this.stream) {
            this.logger.debug({
                action: 'Close connection',
                sessionId: (_c = this.sessionToken) === null || _c === void 0 ? void 0 : _c.sessionId,
            });
        }
    }
    getEventFactory() {
        return this.eventFactory;
    }
    getCharactersList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scene) {
                yield this.loadScene();
            }
            return this.scene.characters;
        });
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.loadScene();
                if (this.state === data_structures_1.ConnectionState.LOADED) {
                    this.state = data_structures_1.ConnectionState.ACTIVATING;
                    this.stream = this.engineService.session(Object.assign({ sessionToken: this.sessionToken, onError: this.onError, onDisconnect: this.onDisconnect }, (this.onMessage && { onMessage: this.onMessage })));
                    this.state = data_structures_1.ConnectionState.ACTIVE;
                    this.releaseQueue();
                    this.scheduleDisconnect();
                }
            }
            catch (err) {
                this.onError(err);
                this.clearQueue();
            }
        });
    }
    send(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.cancelScheduler();
                if (!this.isActive() && !this.isAutoReconnected()) {
                    throw Error('Unable to send data due inactive connection');
                }
                return this.write(getPacket);
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    write(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            let packet;
            const resolvePacket = () => new Promise((resolve) => {
                const done = (packet) => {
                    this.scheduleDisconnect();
                    resolve(this.convertPacketFromProto(packet));
                };
                if (packet) {
                    return done(packet);
                }
                const interval = setInterval(() => {
                    if (packet || this.state === data_structures_1.ConnectionState.INACTIVE) {
                        clearInterval(interval);
                        this.intervals = this.intervals.filter((i) => i !== interval);
                        done(packet);
                    }
                }, 10);
                this.intervals.push(interval);
            });
            if (this.isActive()) {
                packet = this.writeToStream(getPacket);
            }
            else {
                this.packetQueue.push({
                    getPacket,
                    afterWriting: (protoPacket) => {
                        packet = protoPacket;
                    },
                });
                yield this.open();
            }
            return resolvePacket();
        });
    }
    writeToStream(getPacket) {
        var _a, _b;
        const packet = getPacket();
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.write(packet);
        this.logger.debug({
            action: 'Send packet',
            data: {
                packet: packet.toObject(),
            },
            sessionId: (_b = this.sessionToken) === null || _b === void 0 ? void 0 : _b.sessionId,
        });
        return packet;
    }
    loadScene() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state === data_structures_1.ConnectionState.LOADING)
                return;
            let session;
            // Try to get session from provided storage
            if (this.connectionProps.sessionGetterSetter) {
                session = yield this.connectionProps.sessionGetterSetter.get();
            }
            try {
                const previousSessionToken = this.sessionToken;
                yield this.ensureSessionToken({
                    sessionToken: session === null || session === void 0 ? void 0 : session.sessionToken,
                    beforeLoading: () => {
                        this.state = data_structures_1.ConnectionState.LOADING;
                    },
                });
                let changed = previousSessionToken !== this.sessionToken;
                if (!this.scene) {
                    const scene = yield this.getOrLoadScene(session === null || session === void 0 ? void 0 : session.scene);
                    changed = scene !== this.scene || changed;
                    this.scene = scene;
                    if (!this.getEventFactory().getCurrentCharacter() &&
                        this.scene.characters.length) {
                        this.getEventFactory().setCurrentCharacter(this.scene.characters[0]);
                    }
                }
                // Try to save session token to provided storage
                if (changed) {
                    (_a = this.connectionProps.sessionGetterSetter) === null || _a === void 0 ? void 0 : _a.set({
                        sessionToken: this.sessionToken,
                        scene: this.scene,
                    });
                }
                if ([data_structures_1.ConnectionState.LOADING, data_structures_1.ConnectionState.INACTIVE].includes(this.state)) {
                    this.state = data_structures_1.ConnectionState.LOADED;
                }
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    ensureSessionToken(props) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let sessionToken = (_a = props === null || props === void 0 ? void 0 : props.sessionToken) !== null && _a !== void 0 ? _a : this.sessionToken;
            if (!sessionToken || session_token_entity_1.SessionToken.isExpired(sessionToken)) {
                const { sessionId } = sessionToken || {};
                // Generate new session token is it's empty or expired
                if (!sessionToken || session_token_entity_1.SessionToken.isExpired(sessionToken)) {
                    (_b = props === null || props === void 0 ? void 0 : props.beforeLoading) === null || _b === void 0 ? void 0 : _b.call(props);
                    const generateSessionToken = (_c = this.connectionProps.generateSessionToken) !== null && _c !== void 0 ? _c : this.generateSessionToken.bind(this);
                    sessionToken = yield generateSessionToken();
                    // Reuse session id to keep context of previous conversation
                    if (sessionId) {
                        sessionToken = new session_token_entity_1.SessionToken(Object.assign(Object.assign({}, sessionToken), { sessionId }));
                    }
                }
            }
            this.sessionToken = sessionToken;
            return this.sessionToken;
        });
    }
    getOrLoadScene(savedScene) {
        return __awaiter(this, void 0, void 0, function* () {
            let scene = savedScene;
            // Load scene
            if (!scene) {
                const { client, name, sessionContinuation, user } = this.connectionProps;
                const proto = yield this.engineService.loadScene({
                    client,
                    name,
                    sessionContinuation,
                    user,
                    capabilities: this.connectionProps.config.capabilities,
                    sessionToken: this.sessionToken,
                    extension: this.connectionProps.extension,
                });
                scene = scene_entity_1.Scene.fromProto(proto);
            }
            return scene;
        });
    }
    scheduleDisconnect() {
        var _a, _b;
        if ((_b = (_a = this.connectionProps.config) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.disconnectTimeout) {
            this.cancelScheduler();
            this.disconnectTimeoutId = setTimeout(() => this.close(), this.connectionProps.config.connection.disconnectTimeout);
        }
    }
    cancelScheduler() {
        if (this.disconnectTimeoutId) {
            clearTimeout(this.disconnectTimeoutId);
        }
    }
    releaseQueue() {
        this.packetQueue.forEach((item) => {
            const protoPacket = this.writeToStream(item.getPacket);
            item.afterWriting(protoPacket);
        });
        this.packetQueue = [];
    }
    clearQueue() {
        this.intervals.forEach((i) => {
            clearInterval(i);
        });
        this.intervals = [];
        this.packetQueue = [];
    }
    convertPacketFromProto(packet) {
        var _a;
        return ((_a = this.connectionProps.extension) === null || _a === void 0 ? void 0 : _a.convertPacketFromProto)
            ? this.connectionProps.extension.convertPacketFromProto(packet)
            : inworld_packet_entity_1.InworldPacket.fromProto(packet);
    }
}
exports.ConnectionService = ConnectionService;
