"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const path = require("path");
const winston_1 = require("winston");
class Logger {
    constructor() {
        this.FOLDER = process.env.NODE_SDK_INWORLD_LOGGER_FOLDER;
        this.ENABLED =
            process.env.NODE_SDK_INWORLD_LOGGER_ENABLED === 'true' ? true : false;
        if (this.ENABLED) {
            this.logger = (0, winston_1.createLogger)(Object.assign({ format: winston_1.format.combine(winston_1.format.timestamp(), winston_1.format.errors({ stack: true }), winston_1.format.splat(), winston_1.format.json()) }, (this.FOLDER
                ? {
                    exceptionHandlers: [
                        new winston_1.transports.File({
                            filename: path.join(this.FOLDER, 'exceptions.log'),
                        }),
                    ],
                    transports: [
                        this.createTransport('debug', this.FOLDER),
                        this.createTransport('error', this.FOLDER),
                    ],
                }
                : {
                    transports: [
                        this.createTransport('debug'),
                        this.createTransport('error'),
                    ],
                })));
        }
    }
    static getInstance() {
        Logger.instance = Logger.instance || new Logger();
        return Logger.instance;
    }
    debug(message) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(message);
    }
    error(err) {
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(err);
    }
    createTransport(level, folder) {
        return folder
            ? new winston_1.transports.File({
                filename: path.join(folder, `${level}.log`),
                level,
            })
            : new winston_1.transports.Console({ level });
    }
}
exports.Logger = Logger;
